import { mnemonicToEntropy as ue, generateMnemonic as Ue } from "bip39";
import * as n from "@emurgo/cardano-serialization-lib-nodejs";
import ct from "axios";
import { COSEKey as Fe, Label as X, KeyType as ke, AlgorithmId as ge, Int as Qt, BigNum as Yt, CBORValue as Dt, HeaderMap as Ot, Headers as He, ProtectedHeaderMap as Ne, COSESign1Builder as Me } from "@emurgo/cardano-message-signing-nodejs";
import { customAlphabet as Pe } from "nanoid";
const Te = {
  mem: 7e6,
  steps: 3e9
}, N = {
  epoch: 0,
  coinsPerUTxOSize: "4310",
  priceMem: 0.0577,
  priceStep: 721e-7,
  minFeeA: 44,
  minFeeB: 155381,
  keyDeposit: "2000000",
  maxTxSize: 16384,
  maxValSize: "5000",
  poolDeposit: "500000000",
  maxCollateralInputs: 3,
  decentralisation: 0,
  maxBlockSize: 98304,
  collateralPercent: 150,
  maxBlockHeaderSize: 1100,
  minPoolCost: "340000000",
  maxTxExMem: "16000000",
  maxTxExSteps: "10000000000",
  maxBlockExMem: "80000000",
  maxBlockExSteps: "40000000000"
}, St = 2147483648, vt = {
  V1: n.Language.new_plutus_v1(),
  V2: n.Language.new_plutus_v2()
}, L = 56, Ve = {
  CERT: n.RedeemerTag.new_cert(),
  MINT: n.RedeemerTag.new_mint(),
  REWARD: n.RedeemerTag.new_reward(),
  SPEND: n.RedeemerTag.new_spend()
}, _t = {
  testnet: ["74", "1598400", "1595967616", "432000"],
  preview: ["0", "0", "1660003200", "86400"],
  preprod: ["0", "0", "1654041600", "432000"],
  mainnet: ["208", "4492800", "1596059091", "432000"]
}, Gt = {
  ALONZO: n.TxBuilderConstants.plutus_alonzo_cost_models(),
  BABBAGE: n.TxBuilderConstants.plutus_vasil_cost_models()
}, Ye = {
  ALONZO: {
    V1: "a141005901d59f1a000302590001011a00060bc719026d00011a000249f01903e800011a000249f018201a0025cea81971f70419744d186419744d186419744d186419744d186419744d186419744d18641864186419744d18641a000249f018201a000249f018201a000249f018201a000249f01903e800011a000249f018201a000249f01903e800081a000242201a00067e2318760001011a000249f01903e800081a000249f01a0001b79818f7011a000249f0192710011a0002155e19052e011903e81a000249f01903e8011a000249f018201a000249f018201a000249f0182001011a000249f0011a000249f0041a000194af18f8011a000194af18f8011a0002377c190556011a0002bdea1901f1011a000249f018201a000249f018201a000249f018201a000249f018201a000249f018201a000249f018201a000242201a00067e23187600010119f04c192bd200011a000249f018201a000242201a00067e2318760001011a000242201a00067e2318760001011a0025cea81971f704001a000141bb041a000249f019138800011a000249f018201a000302590001011a000249f018201a000249f018201a000249f018201a000249f018201a000249f018201a000249f018201a000249f018201a00330da70101ff"
  },
  BABBAGE: {
    V1: "a141005901b69f1a0003236119032c01011903e819023b00011903e8195e7104011903e818201a0001ca761928eb041959d818641959d818641959d818641959d818641959d818641959d81864186418641959d81864194c5118201a0002acfa182019b551041a000363151901ff00011a00015c3518201a000797751936f404021a0002ff941a0006ea7818dc0001011903e8196ff604021a0003bd081a00034ec5183e011a00102e0f19312a011a00032e801901a5011a0002da781903e819cf06011a00013a34182019a8f118201903e818201a00013aac0119e143041903e80a1a00030219189c011a00030219189c011a0003207c1901d9011a000330001901ff0119ccf3182019fd40182019ffd5182019581e18201940b318201a00012adf18201a0002ff941a0006ea7818dc0001011a00010f92192da7000119eabb18201a0002ff941a0006ea7818dc0001011a0002ff941a0006ea7818dc0001011a000c504e197712041a001d6af61a0001425b041a00040c660004001a00014fab18201a0003236119032c010119a0de18201a00033d7618201979f41820197fb8182019a95d1820197df718201995aa18201a009063b91903fd0aff",
    V2: "a20198af1a0003236119032c01011903e819023b00011903e8195e7104011903e818201a0001ca761928eb041959d818641959d818641959d818641959d818641959d818641959d81864186418641959d81864194c5118201a0002acfa182019b551041a000363151901ff00011a00015c3518201a000797751936f404021a0002ff941a0006ea7818dc0001011903e8196ff604021a0003bd081a00034ec5183e011a00102e0f19312a011a00032e801901a5011a0002da781903e819cf06011a00013a34182019a8f118201903e818201a00013aac0119e143041903e80a1a00030219189c011a00030219189c011a0003207c1901d9011a000330001901ff0119ccf3182019fd40182019ffd5182019581e18201940b318201a00012adf18201a0002ff941a0006ea7818dc0001011a00010f92192da7000119eabb18201a0002ff941a0006ea7818dc0001011a0002ff941a0006ea7818dc0001011a0011b22c1a0005fdde00021a000c504e197712041a001d6af61a0001425b041a00040c660004001a00014fab18201a0003236119032c010119a0de18201a00033d7618201979f41820197fb8182019a95d1820197df718201995aa18201b00000004a817c8001b00000004a817c8001a009063b91903fd0a1b00000004a817c800001b00000004a817c80041005901b69f1a0003236119032c01011903e819023b00011903e8195e7104011903e818201a0001ca761928eb041959d818641959d818641959d818641959d818641959d818641959d81864186418641959d81864194c5118201a0002acfa182019b551041a000363151901ff00011a00015c3518201a000797751936f404021a0002ff941a0006ea7818dc0001011903e8196ff604021a0003bd081a00034ec5183e011a00102e0f19312a011a00032e801901a5011a0002da781903e819cf06011a00013a34182019a8f118201903e818201a00013aac0119e143041903e80a1a00030219189c011a00030219189c011a0003207c1901d9011a000330001901ff0119ccf3182019fd40182019ffd5182019581e18201940b318201a00012adf18201a0002ff941a0006ea7818dc0001011a00010f92192da7000119eabb18201a0002ff941a0006ea7818dc0001011a0002ff941a0006ea7818dc0001011a000c504e197712041a001d6af61a0001425b041a00040c660004001a00014fab18201a0003236119032c010119a0de18201a00033d7618201979f41820197fb8182019a95d1820197df718201995aa18201a009063b91903fd0aff"
  }
};
n.NetworkInfo.testnet().network_id() + "", n.NetworkInfo.mainnet().network_id() + "";
const Lt = [
  "eternl",
  "flint",
  "nami",
  "nufi"
], nt = (s) => n.Address.from_bytes(f(s)), Oe = (s) => n.Bip32PrivateKey.from_bytes(f(s)), Ge = (s) => n.DataHash.from_bytes(f(s)), z = (s) => n.Ed25519KeyHash.from_bytes(f(s)), lt = (s) => n.NativeScript.from_bytes(f(s)), Le = (s) => n.PlutusData.from_bytes(f(s)), pt = (s, t) => n.PlutusScript.from_bytes_with_version(f(s), vt[t]), Re = (s) => n.ScriptRef.from_bytes(f(s)), qe = (s) => n.ScriptHash.from_bytes(f(s)), R = (s) => n.Transaction.from_bytes(f(s)), de = (s) => n.TransactionHash.from_bytes(f(s)), Rt = (s) => n.TransactionUnspentOutput.from_bytes(f(s)), Je = (s) => n.TransactionWitnessSet.from_bytes(f(s)), ze = (s) => n.Value.from_bytes(f(s)), K = (s) => n.Address.from_bech32(s), Ut = (s) => n.BaseAddress.from_address(K(s)), le = (s) => n.EnterpriseAddress.from_address(K(s)), $e = (s) => n.RewardAddress.from_address(K(s)), W = (s) => Buffer.from(s).toString("hex"), f = (s) => s.length % 2 === 0 && /^[0-9A-F]*$/i.test(s) ? Buffer.from(s, "hex") : Buffer.from(s, "utf-8"), Ft = (s) => {
  const t = (e) => {
    const i = new Array();
    for (let r = 0; r < e.len(); r += 1)
      i.push(Ft(e.get(r)));
    return i;
  };
  switch (s.kind()) {
    case n.NativeScriptKind.ScriptAll: {
      const e = s.as_script_all();
      return {
        type: "all",
        scripts: t(e.native_scripts())
      };
    }
    case n.NativeScriptKind.ScriptAny: {
      const e = s.as_script_any();
      return {
        type: "any",
        scripts: t(e.native_scripts())
      };
    }
    case n.NativeScriptKind.ScriptNOfK: {
      const e = s.as_script_n_of_k();
      return {
        type: "atLeast",
        required: e.n(),
        scripts: t(e.native_scripts())
      };
    }
    case n.NativeScriptKind.TimelockStart: {
      const e = s.as_timelock_start();
      return {
        type: "after",
        slot: e.slot_bignum().to_str()
      };
    }
    case n.NativeScriptKind.TimelockExpiry: {
      const e = s.as_timelock_expiry();
      return {
        type: "before",
        slot: e.slot_bignum().to_str()
      };
    }
    case n.NativeScriptKind.ScriptPubkey: {
      const e = s.as_script_pubkey();
      return {
        type: "sig",
        keyHash: e.addr_keyhash().to_hex()
      };
    }
    default:
      throw new Error(`Script Kind: ${s.kind()}, is not supported`);
  }
}, yt = (s) => {
  const t = (e) => {
    const i = n.NativeScripts.new();
    return e.forEach((r) => {
      i.add(yt(r));
    }), i;
  };
  switch (s.type) {
    case "all":
      return n.NativeScript.new_script_all(n.ScriptAll.new(t(s.scripts)));
    case "any":
      return n.NativeScript.new_script_any(n.ScriptAny.new(t(s.scripts)));
    case "atLeast":
      return n.NativeScript.new_script_n_of_k(n.ScriptNOfK.new(s.required, t(s.scripts)));
    case "after":
      return n.NativeScript.new_timelock_start(n.TimelockStart.new_timelockstart(n.BigNum.from_str(s.slot)));
    case "before":
      return n.NativeScript.new_timelock_expiry(n.TimelockExpiry.new_timelockexpiry(n.BigNum.from_str(s.slot)));
    case "sig":
      return n.NativeScript.new_script_pubkey(n.ScriptPubkey.new(z(s.keyHash)));
  }
}, $ = (s) => {
  const t = (e) => {
    const i = n.PlutusList.new();
    return e.forEach((r) => {
      i.add($(r));
    }), i;
  };
  switch (typeof s) {
    case "string":
      return n.PlutusData.new_bytes(f(s));
    case "number":
      return n.PlutusData.new_integer(n.BigInt.from_str(s.toString()));
    case "object":
      if (s instanceof Array) {
        const e = t(s);
        return n.PlutusData.new_list(e);
      } else if (s instanceof Map) {
        const e = n.PlutusMap.new();
        return s.forEach((i, r) => {
          e.insert($(r), $(i));
        }), n.PlutusData.new_map(e);
      } else
        return n.PlutusData.new_constr_plutus_data(n.ConstrPlutusData.new(n.BigNum.from_str(s.alternative.toString()), t(s.fields)));
  }
}, We = (s) => {
  const t = (e) => Ve[e];
  return n.Redeemer.new(t(s.tag), n.BigNum.from_str(s.index.toString()), $(s.data), n.ExUnits.new(n.BigNum.from_str(s.budget.mem.toString()), n.BigNum.from_str(s.budget.steps.toString())));
}, je = (s) => {
  if (s.is_plutus_script()) {
    const e = s.plutus_script();
    return {
      code: e.to_hex(),
      version: Object.keys(vt).find((i) => vt[i].to_hex() === e.language_version().to_hex())
    };
  }
  const t = s.native_script();
  return Ft(t);
}, mt = (s) => {
  if ("code" in s) {
    const t = pt(s.code, s.version);
    return n.ScriptRef.new_plutus_script(t);
  }
  return n.ScriptRef.new_native_script(yt(s));
}, Et = (s) => {
  var r, a, o;
  const t = s.output().has_data_hash() ? (r = s.output().data_hash()) == null ? void 0 : r.to_hex() : void 0, e = s.output().has_plutus_data() ? (a = s.output().plutus_data()) == null ? void 0 : a.to_hex() : void 0, i = s.output().has_script_ref() ? (o = s.output().script_ref()) == null ? void 0 : o.to_hex() : void 0;
  return {
    input: {
      outputIndex: s.input().index(),
      txHash: s.input().transaction_id().to_hex()
    },
    output: {
      address: s.output().address().to_bech32(),
      amount: fe(s.output().amount()),
      dataHash: t,
      plutusData: e,
      scriptRef: i
    }
  };
}, G = (s) => {
  const t = n.TransactionInput.new(de(s.input.txHash), s.input.outputIndex), e = n.TransactionOutput.new(K(s.output.address), ft(s.output.amount));
  return s.output.dataHash !== void 0 && e.set_data_hash(Ge(s.output.dataHash)), s.output.plutusData !== void 0 && e.set_plutus_data(Le(s.output.plutusData)), s.output.scriptRef !== void 0 && e.set_script_ref(Re(s.output.scriptRef)), n.TransactionUnspentOutput.new(t, e);
}, qt = (s) => {
  const t = s.split(".")[1], e = `${parseInt(t, 10)}`, i = "1" + "0".repeat(t.length);
  return n.UnitInterval.new(n.BigNum.from_str(e), n.BigNum.from_str(i));
}, et = (s) => s.length % 2 === 0 && /^[0-9A-F]*$/i.test(s) ? s : W(Buffer.from(s, "utf-8")), Xe = (s) => Buffer.from(s, "hex").toString("utf-8"), fe = (s) => {
  const t = [
    { unit: "lovelace", quantity: s.coin().to_str() }
  ], e = s.multiasset();
  if (e !== void 0) {
    const i = e.keys();
    for (let r = 0; r < i.len(); r += 1) {
      const a = i.get(r), o = e.get(a);
      if (o !== void 0) {
        const A = o.keys();
        for (let c = 0; c < A.len(); c += 1) {
          const h = A.get(c), u = o.get(h) ?? n.BigNum.from_str("0"), I = a.to_hex() + W(h.name());
          t.push({ unit: I, quantity: u.to_str() });
        }
      }
    }
  }
  return t;
}, ft = (s) => {
  const t = s.find((a) => a.unit === "lovelace"), e = Array.from(new Set(s.filter((a) => a.unit !== "lovelace").map((a) => a.unit.slice(0, L)))), i = n.MultiAsset.new();
  e.forEach((a) => {
    const o = n.Assets.new();
    s.filter((A) => A.unit.slice(0, L) === a).forEach((A) => {
      o.insert(n.AssetName.new(f(A.unit.slice(L))), n.BigNum.from_str(A.quantity));
    }), i.insert(qe(a), o);
  });
  const r = n.Value.new(n.BigNum.from_str(t ? t.quantity : "0"));
  return (s.length > 1 || !t) && r.set_multiasset(i), r;
}, Jt = (s, t, e) => n.BaseAddress.new(s, n.StakeCredential.from_keyhash(t), n.StakeCredential.from_keyhash(e)), Ce = (s, t = "") => n.Bip32PrivateKey.from_bip39_entropy(f(s), f(et(t))), zt = (s) => n.DataCost.new_coins_per_byte(n.BigNum.from_str(s)), Ze = (s) => {
  if (typeof s != "object" || !("input" in s))
    return n.DatumSource.new($(s));
  const t = G(s);
  if (t.output().has_plutus_data())
    return n.DatumSource.new_ref_input(t.input());
  throw new Error(`No inline datum found in UTxO: ${t.input().transaction_id().to_hex()}`);
}, $t = (s, t) => n.EnterpriseAddress.new(s, n.StakeCredential.from_keyhash(t)), bt = (s, t) => n.RewardAddress.new(s, n.StakeCredential.from_keyhash(t)), ts = (s) => {
  if ("code" in s)
    return n.PlutusScriptSource.new(pt(s.code, s.version));
  const t = G(s);
  if (t.output().has_script_ref()) {
    const e = t.output().script_ref();
    if (e.is_plutus_script()) {
      const i = je(e), r = pt(i.code, i.version).hash();
      return n.PlutusScriptSource.new_ref_input(r, t.input());
    }
  }
  throw new Error(`No plutus script reference found in UTxO: ${t.input().transaction_id().to_hex()}`);
}, ht = (s) => {
  const t = n.ScriptPubkey.new(s);
  return n.NativeScript.new_script_pubkey(t);
}, es = (s = N) => {
  const t = n.TransactionBuilderConfigBuilder.new().coins_per_utxo_byte(n.BigNum.from_str(s.coinsPerUTxOSize)).ex_unit_prices(n.ExUnitPrices.new(qt(s.priceMem.toString()), qt(s.priceStep.toString()))).fee_algo(n.LinearFee.new(n.BigNum.from_str(s.minFeeA.toString()), n.BigNum.from_str(s.minFeeB.toString()))).key_deposit(n.BigNum.from_str(s.keyDeposit)).max_tx_size(s.maxTxSize).max_value_size(parseInt(s.maxValSize, 10)).pool_deposit(n.BigNum.from_str(s.poolDeposit)).build();
  return n.TransactionBuilder.new(t);
}, Wt = (s) => {
  const t = n.TxInputsBuilder.new();
  return s.map((e) => e instanceof n.TransactionUnspentOutput ? e : G(e)).forEach((e) => {
    t.add_input(e.output().address(), e.input(), e.output().amount());
  }), t;
}, ut = (s) => {
  if (typeof s == "string")
    return n.TransactionOutputBuilder.new().with_address(K(s));
  let t = n.TransactionOutputBuilder.new().with_address(K(s.address));
  if (s.datum) {
    const { value: e, inline: i } = s.datum, r = $(e);
    t = t.with_data_hash(n.hash_plutus_data(r)), i && (t = t.with_plutus_data(r));
  }
  if (s.script) {
    const e = mt(s.script);
    t = t.with_script_ref(e);
  }
  return t;
}, y = (s) => ct.isAxiosError(s) ? s.response ? JSON.stringify({
  data: s.response.data,
  headers: s.response.headers,
  status: s.response.status
}) : s.request ? JSON.stringify(s.request) : s.message : JSON.stringify(s), ss = (s, t, e = !1, { maxTxSize: i, minFeeA: r, minFeeB: a } = N) => {
  const o = t.filter((I) => pe(I) === !1).sort(_e), A = n.BigNum.from_str(ve(i, r, a)), c = e ? n.BigNum.from_str(s).checked_add(A).to_str() : s;
  return Bt(o, /* @__PURE__ */ new Map([
    ["lovelace", c]
  ]));
}, is = (s, t, e = !1, i = N) => {
  const r = t.filter(pe).sort(_e), a = s.get("lovelace") ?? "0", { maxTxSize: o, minFeeA: A, minFeeB: c } = i, h = n.BigNum.from_str(ve(o, A, c)), u = e ? n.BigNum.from_str(a).checked_add(h).to_str() : a;
  return s.set("lovelace", u), Bt(r, s);
}, rs = (s, t) => Array.from(t, (e) => ({ unit: e[0], quantity: n.BigNum.from_str(e[1]) })).every((e) => s.filter((i) => i.output.amount.find((r) => r.unit === e.unit) !== void 0).reduce((i, r) => {
  const a = r.output.amount.reduce((o, A) => o.checked_add(n.BigNum.from_str(A.quantity)), n.BigNum.from_str("0"));
  return i.checked_add(a);
}, n.BigNum.from_str("0")).less_than(e.quantity) === !1), _e = (s, t) => {
  var r, a;
  const e = n.BigNum.from_str(((r = s.output.amount.find((o) => o.unit === "lovelace")) == null ? void 0 : r.quantity) ?? "0");
  return n.BigNum.from_str(((a = t.output.amount.find((o) => o.unit === "lovelace")) == null ? void 0 : a.quantity) ?? "0").compare(e);
}, pe = (s) => s.output.amount.length > 1, Bt = (s, t, e = []) => s.length === 0 || rs(e, t) ? e : ns(s[0], t) ? Bt(s.slice(1), t, [...e, s[0]]) : Bt(s.slice(1), t, e), ns = (s, t) => Array.from(t.keys()).some((e) => s.output.amount.find((i) => i.unit === e) !== void 0), as = (s, t) => {
  const e = os(t), i = As(s, t);
  return {
    coseKey: W(e.to_bytes()),
    coseSign1: W(i.to_bytes())
  };
}, os = (s) => {
  const t = Fe.new(X.from_key_type(ke.OKP));
  return t.set_algorithm_id(X.from_algorithm_id(ge.EdDSA)), t.set_header(X.new_int(Qt.new_negative(Yt.from_str("1"))), Dt.new_int(Qt.new_i32(6))), t.set_header(X.new_int(Qt.new_negative(Yt.from_str("2"))), Dt.new_bytes(s.key.to_public().as_bytes())), t;
}, As = (s, t) => {
  const e = Ot.new(), i = Ot.new();
  e.set_algorithm_id(X.from_algorithm_id(ge.EdDSA)), e.set_header(X.new_text("address"), Dt.new_bytes(t.address.to_bytes()));
  const r = He.new(Ne.new(e), i), a = Me.new(r, f(s.payload), !1);
  s.externalAAD !== void 0 && a.set_external_aad(f(s.externalAAD));
  const o = a.make_data_to_sign(), A = t.key.sign(o.to_bytes());
  return a.build(A.to_bytes());
};
var jt = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, Ee = {}, m = { exports: {} };
M.notEqual = Is;
M.notOk = hs;
M.equal = cs;
M.ok = M;
var Be = M;
function cs(s, t, e) {
  M(s == t, e);
}
function Is(s, t, e) {
  M(s != t, e);
}
function hs(s, t) {
  M(!s, t);
}
function M(s, t) {
  if (!s)
    throw new Error(t || "AssertionError");
}
var U = { exports: {} };
function us(s) {
  throw new Error('Could not dynamically require "' + s + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var gs = kt;
kt.supported = typeof WebAssembly < "u";
function kt(s) {
  if (!kt.supported)
    return null;
  var t = s && s.imports, e = ds("AGFzbQEAAAABEANgAn9/AGADf39/AGABfwADBQQAAQICBQUBAQroBwdNBQZtZW1vcnkCAAxibGFrZTJiX2luaXQAAA5ibGFrZTJiX3VwZGF0ZQABDWJsYWtlMmJfZmluYWwAAhBibGFrZTJiX2NvbXByZXNzAAMK00AElgMAIABCADcDACAAQQhqQgA3AwAgAEEQakIANwMAIABBGGpCADcDACAAQSBqQgA3AwAgAEEoakIANwMAIABBMGpCADcDACAAQThqQgA3AwAgAEHAAGpCADcDACAAQcgAakIANwMAIABB0ABqQgA3AwAgAEHYAGpCADcDACAAQeAAakIANwMAIABB6ABqQgA3AwAgAEHwAGpCADcDACAAQfgAakIANwMAIABBgAFqQoiS853/zPmE6gBBACkDAIU3AwAgAEGIAWpCu86qptjQ67O7f0EIKQMAhTcDACAAQZABakKr8NP0r+68tzxBECkDAIU3AwAgAEGYAWpC8e30+KWn/aelf0EYKQMAhTcDACAAQaABakLRhZrv+s+Uh9EAQSApAwCFNwMAIABBqAFqQp/Y+dnCkdqCm39BKCkDAIU3AwAgAEGwAWpC6/qG2r+19sEfQTApAwCFNwMAIABBuAFqQvnC+JuRo7Pw2wBBOCkDAIU3AwAgAEHAAWpCADcDACAAQcgBakIANwMAIABB0AFqQgA3AwALbQEDfyAAQcABaiEDIABByAFqIQQgBCkDAKchBQJAA0AgASACRg0BIAVBgAFGBEAgAyADKQMAIAWtfDcDAEEAIQUgABADCyAAIAVqIAEtAAA6AAAgBUEBaiEFIAFBAWohAQwACwsgBCAFrTcDAAtkAQN/IABBwAFqIQEgAEHIAWohAiABIAEpAwAgAikDAHw3AwAgAEHQAWpCfzcDACACKQMApyEDAkADQCADQYABRg0BIAAgA2pBADoAACADQQFqIQMMAAsLIAIgA603AwAgABADC+U7AiB+CX8gAEGAAWohISAAQYgBaiEiIABBkAFqISMgAEGYAWohJCAAQaABaiElIABBqAFqISYgAEGwAWohJyAAQbgBaiEoICEpAwAhASAiKQMAIQIgIykDACEDICQpAwAhBCAlKQMAIQUgJikDACEGICcpAwAhByAoKQMAIQhCiJLznf/M+YTqACEJQrvOqqbY0Ouzu38hCkKr8NP0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"), i = null, r = {
    buffer: e,
    memory: null,
    exports: null,
    realloc: a,
    onload: o
  };
  return o(function() {
  }), r;
  function a(c) {
    r.exports.memory.grow(Math.ceil(Math.abs(c - r.memory.length) / 65536)), r.memory = new Uint8Array(r.exports.memory.buffer);
  }
  function o(c) {
    if (r.exports)
      return c();
    if (i) {
      i.then(c.bind(null, null)).catch(c);
      return;
    }
    try {
      if (s && s.async)
        throw new Error("async");
      A({ instance: new WebAssembly.Instance(new WebAssembly.Module(e), t) });
    } catch {
      i = WebAssembly.instantiate(e, t).then(A);
    }
    o(c);
  }
  function A(c) {
    r.exports = c.instance.exports, r.memory = r.exports.memory && r.exports.memory.buffer && new Uint8Array(r.exports.memory.buffer);
  }
}
function ds(s) {
  return typeof atob == "function" ? new Uint8Array(atob(s).split("").map(ls)) : new (us("buffer")).Buffer(s, "base64");
}
function ls(s) {
  return s.charCodeAt(0);
}
var b = Be, l = gs(), H = 64, Ct = [];
U.exports = Q;
var Xt = U.exports.BYTES_MIN = 16, Zt = U.exports.BYTES_MAX = 64;
U.exports.BYTES = 32;
var te = U.exports.KEYBYTES_MIN = 16, ee = U.exports.KEYBYTES_MAX = 64;
U.exports.KEYBYTES = 32;
var se = U.exports.SALTBYTES = 16, ie = U.exports.PERSONALBYTES = 16;
function Q(s, t, e, i, r) {
  if (!(this instanceof Q))
    return new Q(s, t, e, i, r);
  if (!(l && l.exports))
    throw new Error("WASM not loaded. Wait for Blake2b.ready(cb)");
  s || (s = 32), r !== !0 && (b(s >= Xt, "digestLength must be at least " + Xt + ", was given " + s), b(s <= Zt, "digestLength must be at most " + Zt + ", was given " + s), t != null && b(t.length >= te, "key must be at least " + te + ", was given " + t.length), t != null && b(t.length <= ee, "key must be at least " + ee + ", was given " + t.length), e != null && b(e.length === se, "salt must be exactly " + se + ", was given " + e.length), i != null && b(i.length === ie, "personal must be exactly " + ie + ", was given " + i.length)), Ct.length || (Ct.push(H), H += 216), this.digestLength = s, this.finalized = !1, this.pointer = Ct.pop(), l.memory.fill(0, 0, 64), l.memory[0] = this.digestLength, l.memory[1] = t ? t.length : 0, l.memory[2] = 1, l.memory[3] = 1, e && l.memory.set(e, 32), i && l.memory.set(i, 48), this.pointer + 216 > l.memory.length && l.realloc(this.pointer + 216), l.exports.blake2b_init(this.pointer, this.digestLength), t && (this.update(t), l.memory.fill(0, H, H + t.length), l.memory[this.pointer + 200] = 128);
}
Q.prototype.update = function(s) {
  return b(this.finalized === !1, "Hash instance finalized"), b(s, "input must be TypedArray or Buffer"), H + s.length > l.memory.length && l.realloc(H + s.length), l.memory.set(s, H), l.exports.blake2b_update(this.pointer, H, H + s.length), this;
};
Q.prototype.digest = function(s) {
  if (b(this.finalized === !1, "Hash instance finalized"), this.finalized = !0, Ct.push(this.pointer), l.exports.blake2b_final(this.pointer), !s || s === "binary")
    return l.memory.slice(this.pointer + 128, this.pointer + 128 + this.digestLength);
  if (s === "hex")
    return Cs(l.memory, this.pointer + 128, this.digestLength);
  b(s.length >= this.digestLength, "input must be TypedArray or Buffer");
  for (var t = 0; t < this.digestLength; t++)
    s[t] = l.memory[this.pointer + 128 + t];
  return s;
};
Q.prototype.final = Q.prototype.digest;
Q.WASM = l && l.buffer;
Q.SUPPORTED = typeof WebAssembly < "u";
Q.ready = function(s) {
  if (s || (s = fs), !l)
    return s(new Error("WebAssembly not supported"));
  var t = new Promise(function(e, i) {
    l.onload(function(r) {
      r ? i() : e(), s(r);
    });
  });
  return t;
};
Q.prototype.ready = Q.ready;
function fs() {
}
function Cs(s, t, e) {
  for (var i = "", r = 0; r < e; r++)
    i += _s(s[t + r]);
  return i;
}
function _s(s) {
  return s < 16 ? "0" + s.toString(16) : s.toString(16);
}
var O = Be, At = U.exports;
function gt(s, t, e) {
  var i = s[t] + s[e], r = s[t + 1] + s[e + 1];
  i >= 4294967296 && r++, s[t] = i, s[t + 1] = r;
}
function re(s, t, e, i) {
  var r = s[t] + e;
  e < 0 && (r += 4294967296);
  var a = s[t + 1] + i;
  r >= 4294967296 && a++, s[t] = r, s[t + 1] = a;
}
function we(s, t) {
  return s[t] ^ s[t + 1] << 8 ^ s[t + 2] << 16 ^ s[t + 3] << 24;
}
function V(s, t, e, i, r, a) {
  var o = at[r], A = at[r + 1], c = at[a], h = at[a + 1];
  gt(g, s, t), re(g, s, o, A);
  var u = g[i] ^ g[s], I = g[i + 1] ^ g[s + 1];
  g[i] = I, g[i + 1] = u, gt(g, e, i), u = g[t] ^ g[e], I = g[t + 1] ^ g[e + 1], g[t] = u >>> 24 ^ I << 8, g[t + 1] = I >>> 24 ^ u << 8, gt(g, s, t), re(g, s, c, h), u = g[i] ^ g[s], I = g[i + 1] ^ g[s + 1], g[i] = u >>> 16 ^ I << 16, g[i + 1] = I >>> 16 ^ u << 16, gt(g, e, i), u = g[t] ^ g[e], I = g[t + 1] ^ g[e + 1], g[t] = I >>> 31 ^ u << 1, g[t + 1] = u >>> 31 ^ I << 1;
}
var ye = new Uint32Array([
  4089235720,
  1779033703,
  2227873595,
  3144134277,
  4271175723,
  1013904242,
  1595750129,
  2773480762,
  2917565137,
  1359893119,
  725511199,
  2600822924,
  4215389547,
  528734635,
  327033209,
  1541459225
]), ps = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3,
  11,
  8,
  12,
  0,
  5,
  2,
  15,
  13,
  10,
  14,
  3,
  6,
  7,
  1,
  9,
  4,
  7,
  9,
  3,
  1,
  13,
  12,
  11,
  14,
  2,
  6,
  5,
  10,
  4,
  0,
  15,
  8,
  9,
  0,
  5,
  7,
  2,
  4,
  10,
  15,
  14,
  1,
  11,
  12,
  6,
  8,
  3,
  13,
  2,
  12,
  6,
  10,
  0,
  11,
  8,
  3,
  4,
  13,
  7,
  5,
  15,
  14,
  1,
  9,
  12,
  5,
  1,
  15,
  14,
  13,
  4,
  10,
  0,
  7,
  6,
  3,
  9,
  2,
  8,
  11,
  13,
  11,
  7,
  14,
  12,
  1,
  3,
  9,
  5,
  0,
  15,
  4,
  8,
  6,
  2,
  10,
  6,
  15,
  14,
  9,
  11,
  3,
  0,
  8,
  12,
  2,
  13,
  7,
  1,
  4,
  10,
  5,
  10,
  2,
  8,
  4,
  7,
  6,
  1,
  5,
  15,
  11,
  9,
  14,
  3,
  12,
  13,
  0,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3
], B = new Uint8Array(ps.map(function(s) {
  return s * 2;
})), g = new Uint32Array(32), at = new Uint32Array(32);
function me(s, t) {
  var e = 0;
  for (e = 0; e < 16; e++)
    g[e] = s.h[e], g[e + 16] = ye[e];
  for (g[24] = g[24] ^ s.t, g[25] = g[25] ^ s.t / 4294967296, t && (g[28] = ~g[28], g[29] = ~g[29]), e = 0; e < 32; e++)
    at[e] = we(s.b, 4 * e);
  for (e = 0; e < 12; e++)
    V(0, 8, 16, 24, B[e * 16 + 0], B[e * 16 + 1]), V(2, 10, 18, 26, B[e * 16 + 2], B[e * 16 + 3]), V(4, 12, 20, 28, B[e * 16 + 4], B[e * 16 + 5]), V(6, 14, 22, 30, B[e * 16 + 6], B[e * 16 + 7]), V(0, 10, 20, 30, B[e * 16 + 8], B[e * 16 + 9]), V(2, 12, 22, 24, B[e * 16 + 10], B[e * 16 + 11]), V(4, 14, 16, 26, B[e * 16 + 12], B[e * 16 + 13]), V(6, 8, 18, 28, B[e * 16 + 14], B[e * 16 + 15]);
  for (e = 0; e < 16; e++)
    s.h[e] = s.h[e] ^ g[e] ^ g[e + 16];
}
var Y = new Uint8Array([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
]);
function st(s, t, e, i) {
  Y.fill(0), this.b = new Uint8Array(128), this.h = new Uint32Array(16), this.t = 0, this.c = 0, this.outlen = s, Y[0] = s, t && (Y[1] = t.length), Y[2] = 1, Y[3] = 1, e && Y.set(e, 32), i && Y.set(i, 48);
  for (var r = 0; r < 16; r++)
    this.h[r] = ye[r] ^ we(Y, r * 4);
  t && (Qe(this, t), this.c = 128);
}
st.prototype.update = function(s) {
  return O(s != null, "input must be Uint8Array or Buffer"), Qe(this, s), this;
};
st.prototype.digest = function(s) {
  var t = !s || s === "binary" || s === "hex" ? new Uint8Array(this.outlen) : s;
  return O(t.length >= this.outlen, "out must have at least outlen bytes of space"), Es(this, t), s === "hex" ? Bs(t) : t;
};
st.prototype.final = st.prototype.digest;
st.ready = function(s) {
  At.ready(function() {
    s();
  });
};
function Qe(s, t) {
  for (var e = 0; e < t.length; e++)
    s.c === 128 && (s.t += s.c, me(s, !1), s.c = 0), s.b[s.c++] = t[e];
}
function Es(s, t) {
  for (s.t += s.c; s.c < 128; )
    s.b[s.c++] = 0;
  me(s, !0);
  for (var e = 0; e < s.outlen; e++)
    t[e] = s.h[e >> 2] >> 8 * (e & 3);
  return t;
}
function Bs(s) {
  for (var t = "", e = 0; e < s.length; e++)
    t += ws(s[e]);
  return t;
}
function ws(s) {
  return s < 16 ? "0" + s.toString(16) : s.toString(16);
}
var Se = st;
m.exports = function(t, e, i, r, a) {
  return a !== !0 && (O(t >= ne, "outlen must be at least " + ne + ", was given " + t), O(t <= ae, "outlen must be at most " + ae + ", was given " + t), e != null && O(e.length >= oe, "key must be at least " + oe + ", was given " + e.length), e != null && O(e.length <= Ae, "key must be at most " + Ae + ", was given " + e.length), i != null && O(i.length === ce, "salt must be exactly " + ce + ", was given " + i.length), r != null && O(r.length === Ie, "personal must be exactly " + Ie + ", was given " + r.length)), new Se(t, e, i, r);
};
m.exports.ready = function(s) {
  At.ready(function() {
    s();
  });
};
m.exports.WASM_SUPPORTED = At.SUPPORTED;
m.exports.WASM_LOADED = !1;
var ne = m.exports.BYTES_MIN = 16, ae = m.exports.BYTES_MAX = 64;
m.exports.BYTES = 32;
var oe = m.exports.KEYBYTES_MIN = 16, Ae = m.exports.KEYBYTES_MAX = 64;
m.exports.KEYBYTES = 32;
var ce = m.exports.SALTBYTES = 16, Ie = m.exports.PERSONALBYTES = 16;
At.ready(function(s) {
  s || (m.exports.WASM_LOADED = !0, Se = At);
});
var it = {};
Object.defineProperty(it, "__esModule", { value: !0 });
it.bech32m = it.bech32 = void 0;
const wt = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", xe = {};
for (let s = 0; s < wt.length; s++) {
  const t = wt.charAt(s);
  xe[t] = s;
}
function tt(s) {
  const t = s >> 25;
  return (s & 33554431) << 5 ^ -(t >> 0 & 1) & 996825010 ^ -(t >> 1 & 1) & 642813549 ^ -(t >> 2 & 1) & 513874426 ^ -(t >> 3 & 1) & 1027748829 ^ -(t >> 4 & 1) & 705979059;
}
function he(s) {
  let t = 1;
  for (let e = 0; e < s.length; ++e) {
    const i = s.charCodeAt(e);
    if (i < 33 || i > 126)
      return "Invalid prefix (" + s + ")";
    t = tt(t) ^ i >> 5;
  }
  t = tt(t);
  for (let e = 0; e < s.length; ++e) {
    const i = s.charCodeAt(e);
    t = tt(t) ^ i & 31;
  }
  return t;
}
function Ht(s, t, e, i) {
  let r = 0, a = 0;
  const o = (1 << e) - 1, A = [];
  for (let c = 0; c < s.length; ++c)
    for (r = r << t | s[c], a += t; a >= e; )
      a -= e, A.push(r >> a & o);
  if (i)
    a > 0 && A.push(r << e - a & o);
  else {
    if (a >= t)
      return "Excess padding";
    if (r << e - a & o)
      return "Non-zero padding";
  }
  return A;
}
function ys(s) {
  return Ht(s, 8, 5, !0);
}
function ms(s) {
  const t = Ht(s, 5, 8, !1);
  if (Array.isArray(t))
    return t;
}
function Qs(s) {
  const t = Ht(s, 5, 8, !1);
  if (Array.isArray(t))
    return t;
  throw new Error(t);
}
function De(s) {
  let t;
  s === "bech32" ? t = 1 : t = 734539939;
  function e(o, A, c) {
    if (c = c || 90, o.length + 7 + A.length > c)
      throw new TypeError("Exceeds length limit");
    o = o.toLowerCase();
    let h = he(o);
    if (typeof h == "string")
      throw new Error(h);
    let u = o + "1";
    for (let I = 0; I < A.length; ++I) {
      const p = A[I];
      if (p >> 5 !== 0)
        throw new Error("Non 5-bit word");
      h = tt(h) ^ p, u += wt.charAt(p);
    }
    for (let I = 0; I < 6; ++I)
      h = tt(h);
    h ^= t;
    for (let I = 0; I < 6; ++I) {
      const p = h >> (5 - I) * 5 & 31;
      u += wt.charAt(p);
    }
    return u;
  }
  function i(o, A) {
    if (A = A || 90, o.length < 8)
      return o + " too short";
    if (o.length > A)
      return "Exceeds length limit";
    const c = o.toLowerCase(), h = o.toUpperCase();
    if (o !== c && o !== h)
      return "Mixed-case string " + o;
    o = c;
    const u = o.lastIndexOf("1");
    if (u === -1)
      return "No separator character for " + o;
    if (u === 0)
      return "Missing prefix for " + o;
    const I = o.slice(0, u), p = o.slice(u + 1);
    if (p.length < 6)
      return "Data too short";
    let D = he(I);
    if (typeof D == "string")
      return D;
    const J = [];
    for (let F = 0; F < p.length; ++F) {
      const T = p.charAt(F), d = xe[T];
      if (d === void 0)
        return "Unknown character " + T;
      D = tt(D) ^ d, !(F + 6 >= p.length) && J.push(d);
    }
    return D !== t ? "Invalid checksum for " + o : { prefix: I, words: J };
  }
  function r(o, A) {
    const c = i(o, A);
    if (typeof c == "object")
      return c;
  }
  function a(o, A) {
    const c = i(o, A);
    if (typeof c == "object")
      return c;
    throw new Error(c);
  }
  return {
    decodeUnsafe: r,
    decode: a,
    encode: e,
    toWords: ys,
    fromWordsUnsafe: ms,
    fromWords: Qs
  };
}
it.bech32 = De("bech32");
it.bech32m = De("bech32m");
var Ss = jt && jt.__importDefault || function(s) {
  return s && s.__esModule ? s : { default: s };
};
Object.defineProperty(Ee, "__esModule", { value: !0 });
const xs = Ss(m.exports), dt = it, xt = "asset";
class ot {
  constructor(t) {
    this.hashBuf = t;
  }
  static fromHash(t) {
    return new ot(t);
  }
  static fromParts(t, e) {
    const i = (0, xs.default)(20).update(new Uint8Array([...t, ...e])).digest("binary");
    return ot.fromHash(i);
  }
  static fromBech32(t) {
    const { prefix: e, words: i } = dt.bech32.decode(t);
    if (e !== xt)
      throw new Error("Invalid asset fingerprint");
    const r = Buffer.from(dt.bech32.fromWords(i));
    return ot.fromHash(r);
  }
  fingerprint() {
    const t = dt.bech32.toWords(this.hashBuf);
    return dt.bech32.encode(xt, t);
  }
  hash() {
    return Buffer.from(this.hashBuf).toString("hex");
  }
  prefix() {
    return xt;
  }
  checksum() {
    return this.fingerprint().slice(-6);
  }
}
var Ds = Ee.default = ot;
const vs = Ds, bs = (s, t) => {
  const e = Oe(s), i = e.derive(St + 1852).derive(St + 1815).derive(St + t), r = i.derive(0).derive(0).to_raw_key(), a = i.derive(2).derive(0).to_raw_key();
  return i.free(), e.free(), { paymentKey: r, stakeKey: a };
}, Os = (s) => {
  const t = $(s);
  return n.hash_plutus_data(t).to_hex();
}, Gs = (s, t = Date.now()) => {
  if (_t[s]) {
    const [e, i, r, a] = _t[s];
    return parseInt(n.BigNum.from_str(t.toString()).div_floor(n.BigNum.from_str("1000")).checked_sub(n.BigNum.from_str(r)).div_floor(n.BigNum.from_str(a)).checked_add(n.BigNum.from_str(e)).to_str(), 10);
  }
  throw new Error(`Couldn't resolve EpochNo for network: ${s}`);
}, Ks = (s, t) => vs.fromParts(f(s), f(t)).fingerprint(), Ls = (s, t) => Ye[s][t], Rs = (s) => yt(s).hash().to_hex(), Z = (s) => {
  var t, e;
  try {
    const i = [
      (t = Ut(s)) == null ? void 0 : t.payment_cred().to_keyhash(),
      (e = le(s)) == null ? void 0 : e.payment_cred().to_keyhash()
    ].find((r) => r !== void 0);
    if (i !== void 0)
      return i.to_hex();
    throw new Error(`Couldn't resolve payment key hash from address: ${s}`);
  } catch (i) {
    throw new Error(`An error occurred during resolvePaymentKeyHash: ${i}.`);
  }
}, qs = (s, t = 0) => {
  const e = pt(s.code, s.version);
  return n.EnterpriseAddress.new(t, n.StakeCredential.from_scripthash(e.hash())).to_address().to_bech32();
}, Js = (s) => {
  try {
    const t = le(s), e = t == null ? void 0 : t.payment_cred().to_scripthash();
    if (e !== void 0)
      return e.to_hex();
    throw new Error(`Couldn't resolve script hash from address: ${s}`);
  } catch (t) {
    throw new Error(`An error occurred during resolveScriptHash: ${t}.`);
  }
}, zs = (s) => {
  const t = ue(s.join(" ")), e = Ce(t), i = e.to_bech32();
  return e.free(), i;
}, $s = (s) => mt(s).to_hex(), Ws = (s, t = Date.now()) => {
  if (_t[s]) {
    const [e, i, r] = _t[s];
    return n.BigNum.from_str(t.toString()).div_floor(n.BigNum.from_str("1000")).checked_sub(n.BigNum.from_str(r)).checked_add(n.BigNum.from_str(i)).to_str();
  }
  throw new Error(`Couldn't resolve SlotNo for network: ${s}`);
}, js = (s) => {
  try {
    const t = K(s), e = Ut(s), i = e == null ? void 0 : e.stake_cred().to_keyhash();
    if (i !== void 0)
      return bt(t.network_id(), i).to_address().to_bech32();
    throw new Error(`Couldn't resolve stake address from address: ${s}`);
  } catch (t) {
    throw new Error(`An error occurred during resolveStakeAddress: ${t}.`);
  }
}, Us = (s) => {
  var t, e;
  try {
    const i = [
      (t = Ut(s)) == null ? void 0 : t.stake_cred().to_keyhash(),
      (e = $e(s)) == null ? void 0 : e.payment_cred().to_keyhash()
    ].find((r) => r !== void 0);
    if (i !== void 0)
      return i.to_hex();
    throw new Error(`Couldn't resolve stake key hash from address: ${s}`);
  } catch (i) {
    throw new Error(`An error occurred during resolveStakeKeyHash: ${i}.`);
  }
}, ve = (s, t = N.minFeeA, e = N.minFeeB) => (BigInt(t) * BigInt(s) + BigInt(e)).toString(), Fs = (s) => {
  const t = R(s).body();
  return n.hash_transaction(t).to_hex();
};
class Xs {
  _axiosInstance;
  constructor(t, e = 0) {
    const i = t.slice(0, 7);
    this._axiosInstance = ct.create({
      baseURL: `https://cardano-${i}.blockfrost.io/api/v${e}`,
      headers: { project_id: t }
    });
  }
  async fetchAddressUTxOs(t, e) {
    const i = e !== void 0 ? `/${e}` : "", r = `addresses/${t}/utxos` + i, a = async (c = 1, h = []) => {
      const { data: u, status: I } = await this._axiosInstance.get(`${r}?page=${c}`);
      if (I === 200)
        return u.length > 0 ? a(c + 1, [...h, ...await Promise.all(u.map(A))]) : h;
      throw y(u);
    }, o = async (c) => {
      if (c) {
        const { data: h, status: u } = await this._axiosInstance.get(`scripts/${c}`);
        if (u === 200) {
          const I = h.type.startsWith("plutus") ? {
            code: await this.fetchPlutusScriptCBOR(c),
            version: h.type.replace("plutus", "")
          } : await this.fetchNativeScriptJSON(c);
          return mt(I).to_hex();
        }
        throw y(h);
      }
    }, A = async (c) => ({
      input: {
        outputIndex: c.output_index,
        txHash: c.tx_hash
      },
      output: {
        address: t,
        amount: c.amount,
        dataHash: c.data_hash ?? void 0,
        plutusData: c.inline_datum ?? void 0,
        scriptRef: await o(c.reference_script_hash)
      }
    });
    try {
      return await a();
    } catch {
      return [];
    }
  }
  async fetchAssetMetadata(t) {
    throw new Error("fetchAssetMetadata not implemented.");
  }
  async fetchHandleAddress(t) {
    throw new Error("fetchHandleAddress not implemented.");
  }
  async fetchProtocolParameters(t = Number.NaN) {
    try {
      const { data: e, status: i } = await this._axiosInstance.get(`epochs/${isNaN(t) ? "latest" : t}/parameters`);
      if (i === 200)
        return {
          coinsPerUTxOSize: e.coins_per_utxo_word,
          collateralPercent: e.collateral_percent,
          decentralisation: e.decentralisation_param,
          epoch: e.epoch,
          keyDeposit: e.key_deposit,
          maxBlockExMem: e.max_block_ex_mem,
          maxBlockExSteps: e.max_block_ex_steps,
          maxBlockHeaderSize: e.max_block_header_size,
          maxBlockSize: e.max_block_size,
          maxCollateralInputs: e.max_collateral_inputs,
          maxTxExMem: e.max_tx_ex_mem,
          maxTxExSteps: e.max_tx_ex_steps,
          maxTxSize: e.max_tx_size,
          maxValSize: e.max_val_size,
          minFeeA: e.min_fee_a,
          minFeeB: e.min_fee_b,
          minPoolCost: e.min_pool_cost,
          poolDeposit: e.pool_deposit,
          priceMem: e.price_mem,
          priceStep: e.price_step
        };
      throw y(e);
    } catch (e) {
      throw y(e);
    }
  }
  async submitTx(t) {
    try {
      const e = { "Content-Type": "application/cbor" }, { data: i, status: r } = await this._axiosInstance.post("tx/submit", f(t), { headers: e });
      if (r === 200)
        return i;
      throw y(i);
    } catch (e) {
      throw y(e);
    }
  }
  async fetchPlutusScriptCBOR(t) {
    const { data: e, status: i } = await this._axiosInstance.get(`scripts/${t}/cbor`);
    if (i === 200)
      return e.cbor;
    throw y(e);
  }
  async fetchNativeScriptJSON(t) {
    const { data: e, status: i } = await this._axiosInstance.get(`scripts/${t}/json`);
    if (i === 200)
      return e.json;
    throw y(e);
  }
}
class Zs {
  _axiosInstance;
  constructor(t, e, i) {
    const r = i.host ?? "ipfs.infura.io", a = i.port ?? 5001, o = i.version ?? 0;
    this._axiosInstance = ct.create({
      baseURL: `https://${r}:${a}/api/v${o}`,
      auth: { username: t, password: e }
    });
  }
  async uploadContent(t, e = !1) {
    try {
      const i = { "Content-Type": "multipart/form-data" }, { data: r, status: a } = await this._axiosInstance.post(`add?recursive=${e}`, t, { headers: i });
      if (a === 200)
        return r;
      throw y(r);
    } catch (i) {
      throw y(i);
    }
  }
}
class ti {
  _axiosInstance;
  constructor(t, e = 0) {
    this._axiosInstance = ct.create({
      baseURL: `https://${t}.koios.rest/api/v${e}`
    });
  }
  async fetchAddressUTxOs(t, e) {
    const i = (r) => {
      if (r) {
        const a = r.type.startsWith("plutus") ? {
          code: r.bytes,
          version: r.type.replace("plutus", "")
        } : Ft(lt(r.bytes));
        return mt(a).to_hex();
      }
    };
    try {
      const { data: r, status: a } = await this._axiosInstance.post("address_info", { _addresses: [t] });
      if (a === 200) {
        const o = r.flatMap((A) => A.utxo_set).map((A) => ({
          input: {
            outputIndex: A.tx_index,
            txHash: A.tx_hash
          },
          output: {
            address: t,
            amount: [
              { unit: "lovelace", quantity: A.value },
              ...A.asset_list.map((c) => ({
                unit: `${c.policy_id}${c.asset_name}`,
                quantity: `${c.quantity}`
              }))
            ],
            dataHash: A.datum_hash ?? void 0,
            plutusData: A.inline_datum.bytes ?? void 0,
            scriptRef: i(A.reference_script)
          }
        }));
        return e !== void 0 ? o.filter((A) => A.output.amount.find((c) => c.unit === e) !== void 0) : o;
      }
      throw y(r);
    } catch {
      return [];
    }
  }
  async fetchAssetMetadata(t) {
    throw new Error("fetchAssetMetadata not implemented.");
  }
  async fetchHandleAddress(t) {
    throw new Error("fetchHandleAddress not implemented.");
  }
  async fetchProtocolParameters(t) {
    try {
      const { data: e, status: i } = await this._axiosInstance.get(`epoch_params?_epoch_no=${t}`);
      if (i === 200)
        return {
          coinsPerUTxOSize: e[0].coins_per_utxo_size,
          collateralPercent: e[0].collateral_percent,
          decentralisation: e[0].decentralisation,
          epoch: e[0].epoch_no,
          keyDeposit: e[0].key_deposit,
          maxBlockExMem: e[0].max_block_ex_mem.toString(),
          maxBlockExSteps: e[0].max_block_ex_steps.toString(),
          maxBlockHeaderSize: e[0].max_bh_size,
          maxBlockSize: e[0].max_block_size,
          maxCollateralInputs: e[0].max_collateral_inputs,
          maxTxExMem: e[0].max_tx_ex_mem.toString(),
          maxTxExSteps: e[0].max_tx_ex_steps.toString(),
          maxTxSize: e[0].max_tx_size,
          maxValSize: e[0].max_val_size.toString(),
          minFeeA: e[0].min_fee_a,
          minFeeB: e[0].min_fee_b,
          minPoolCost: e[0].min_pool_cost,
          poolDeposit: e[0].pool_deposit,
          priceMem: e[0].price_mem,
          priceStep: e[0].price_step
        };
      throw y(e);
    } catch (e) {
      throw y(e);
    }
  }
  async submitTx(t) {
    try {
      const e = { "Content-Type": "application/cbor" }, { data: i, status: r } = await this._axiosInstance.post("submittx", f(t), { headers: e });
      if (r === 202)
        return i;
      throw y(i);
    } catch (e) {
      throw y(e);
    }
  }
}
class ei {
  static withOneSignature(t) {
    const e = z(Z(t));
    return ht(e).to_hex();
  }
  static withAtLeastNSignatures(t, e) {
    const i = n.NativeScripts.new();
    t.forEach((a) => {
      const o = z(Z(a));
      i.add(ht(o));
    });
    const r = n.ScriptNOfK.new(e, i);
    return n.NativeScript.new_script_any(r).to_hex();
  }
  static withAnySignature(t) {
    const e = n.NativeScripts.new();
    t.forEach((r) => {
      const a = z(Z(r));
      e.add(ht(a));
    });
    const i = n.ScriptAny.new(e);
    return n.NativeScript.new_script_any(i).to_hex();
  }
  static withAllSignatures(t) {
    const e = n.NativeScripts.new();
    t.forEach((r) => {
      const a = z(Z(r));
      e.add(ht(a));
    });
    const i = n.ScriptAll.new(e);
    return n.NativeScript.new_script_any(i).to_hex();
  }
  static fromNativeScript(t) {
    return yt(t).to_hex();
  }
}
function q(s, t, e, i) {
  var r = arguments.length, a = r < 3 ? t : i === null ? i = Object.getOwnPropertyDescriptor(t, e) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    a = Reflect.decorate(s, t, e, i);
  else
    for (var A = s.length - 1; A >= 0; A--)
      (o = s[A]) && (a = (r < 3 ? o(a) : r > 3 ? o(t, e, a) : o(t, e)) || a);
  return r > 3 && a && Object.defineProperty(t, e, a), a;
}
const ks = (s) => class extends s {
  __visits = [];
}, j = () => function(s, t, e) {
  const i = e.value;
  e.value = function(...r) {
    const a = i.call(this, ...r);
    return this.__visits && this.__visits.push(t), a;
  };
};
let P = class {
  _changeAddress;
  _recipients = /* @__PURE__ */ new Map();
  _totalBurns = /* @__PURE__ */ new Map();
  _totalMints = /* @__PURE__ */ new Map();
  _era;
  _initiator;
  _protocolParameters;
  _txBuilder;
  _txInputsBuilder;
  constructor(t = {}) {
    this._era = t.era, this._initiator = t.initiator, this._protocolParameters = t.parameters ?? N, this._txBuilder = es(t.parameters), this._txInputsBuilder = n.TxInputsBuilder.new();
  }
  get size() {
    return this._txBuilder.full_size();
  }
  static maskMetadata(t) {
    var r;
    const e = R(t), i = (r = e.auxiliary_data()) == null ? void 0 : r.metadata();
    if (i !== void 0) {
      const a = n.GeneralTransactionMetadata.new();
      for (let A = 0; A < i.len(); A += 1) {
        const c = i.keys().get(A), h = i.get(c);
        a.insert(c, n.TransactionMetadatum.from_hex("0".repeat(((h == null ? void 0 : h.to_hex()) ?? "").length)));
      }
      const o = e.auxiliary_data();
      return o == null || o.set_metadata(a), n.Transaction.new(e.body(), e.witness_set(), o).to_hex();
    }
    return t;
  }
  static readMetadata(t) {
    var i, r;
    return ((r = (i = R(t).auxiliary_data()) == null ? void 0 : i.metadata()) == null ? void 0 : r.to_hex()) ?? "";
  }
  static writeMetadata(t, e) {
    const i = R(t), r = i.auxiliary_data() ?? n.AuxiliaryData.new();
    return r.set_metadata(n.GeneralTransactionMetadata.from_hex(e)), n.Transaction.new(i.body(), i.witness_set(), r).to_hex();
  }
  async build() {
    try {
      return this.notVisited("redeemValue") === !1 && (await this.addCollateralIfNeeded(), await this.addRequiredSignersIfNeeded()), await this.forgeAssetsIfNeeded(), await this.addTxInputsAsNeeded(), await this.addChangeAddress(), this._txBuilder.build_tx().to_hex();
    } catch (t) {
      throw new Error(`[Transaction] An error occurred during build: ${t}.`);
    }
  }
  burnAsset(t, e) {
    const i = this._totalBurns.has(e.unit) ? n.BigNum.from_str(this._totalBurns.get(e.unit) ?? "0").checked_add(n.BigNum.from_str(e.quantity)).to_str() : e.quantity;
    return this._txBuilder.add_mint_asset(lt(t), n.AssetName.new(f(e.unit.slice(L))), n.Int.new_negative(n.BigNum.from_str(e.quantity))), this._totalBurns.set(e.unit, i), this;
  }
  mintAsset(t, e) {
    var A, c;
    const r = ((h, u) => {
      const I = lt(h).hash().to_hex(), p = et(u.assetName);
      return {
        unit: `${I}${p}`,
        quantity: u.assetQuantity
      };
    })(t, e), o = n.BigNum.from_str(((A = this._totalMints.get(r.unit)) == null ? void 0 : A.assetQuantity) ?? "0").checked_add(n.BigNum.from_str(r.quantity));
    return this._txBuilder.add_mint_asset(lt(t), n.AssetName.new(f(et(e.assetName))), n.Int.new(n.BigNum.from_str(r.quantity))), this._recipients.has(e.recipient) ? (c = this._recipients.get(e.recipient)) == null || c.push(r) : this._recipients.set(e.recipient, [r]), this._totalMints.set(r.unit, {
      ...e,
      assetQuantity: o.to_str()
    }), this;
  }
  redeemValue(t) {
    if ("assetName" in t.value)
      throw new Error("Plutus Minting is not implemented yet...");
    const e = {
      tag: "SPEND",
      budget: Te,
      index: this._txInputsBuilder.inputs().len(),
      data: {
        alternative: 0,
        fields: []
      },
      ...t.redeemer
    }, i = G(t.value), r = n.PlutusWitness.new_with_ref(ts(t.script), Ze(t.datum), We(e));
    return this._txInputsBuilder.add_plutus_script_input(r, i.input(), i.output().amount()), this;
  }
  sendAssets(t, e) {
    const i = ft(e), r = i.multiasset();
    if (i.is_zero() || r === void 0)
      return this;
    const o = ut(t).next().with_asset_and_min_required_coin_by_utxo_cost(r, zt(this._protocolParameters.coinsPerUTxOSize)).build();
    return this._txBuilder.add_output(o), this;
  }
  sendLovelace(t, e) {
    const r = ut(t).next().with_coin(n.BigNum.from_str(e)).build();
    return this._txBuilder.add_output(r), this;
  }
  sendValue(t, e) {
    const i = ft(e.output.amount), a = ut(t).next().with_value(i).build();
    return this._txBuilder.add_output(a), this;
  }
  setChangeAddress(t) {
    return this._changeAddress = K(t), this;
  }
  setCollateral(t) {
    const e = Wt(t);
    return this._txBuilder.set_collateral(e), this;
  }
  setMetadata(t, e) {
    return this._txBuilder.add_json_metadatum_with_schema(n.BigNum.from_str(t.toString()), JSON.stringify(e), n.MetadataJsonSchema.NoConversions), this;
  }
  setRequiredSigners(t) {
    return Array.from(new Set(t.map((i) => i.startsWith("addr") ? Z(i) : Us(i)).map((i) => z(i)))).forEach((i) => {
      this._txBuilder.add_required_signer(i);
    }), this;
  }
  setTimeToStart(t) {
    return this._txBuilder.set_validity_start_interval_bignum(n.BigNum.from_str(t)), this;
  }
  setTimeToExpire(t) {
    return this._txBuilder.set_ttl_bignum(n.BigNum.from_str(t)), this;
  }
  setTxInputs(t) {
    return t.map((e) => G(e)).forEach((e) => {
      this._txInputsBuilder.add_input(e.output().address(), e.input(), e.output().amount());
    }), this;
  }
  async addBurnInputsIfNeeded() {
    if (this._initiator && this._totalBurns.size > 0 && this.notVisited("setTxInputs")) {
      const t = await this._initiator.getUsedUTxOs();
      is(this._totalBurns, t.map((i) => Et(i))).map((i) => G(i)).forEach((i) => {
        this._txInputsBuilder.add_input(i.output().address(), i.input(), i.output().amount());
      });
    }
  }
  async addChangeAddress() {
    if (this._initiator && this._changeAddress === void 0) {
      const t = await this._initiator.getUsedAddress();
      this._txBuilder.add_change_if_needed(t);
    } else
      this._changeAddress !== void 0 && this._txBuilder.add_change_if_needed(this._changeAddress);
  }
  async addCollateralIfNeeded() {
    if (this._initiator && this.notVisited("setCollateral")) {
      const t = await this._initiator.getUsedCollateral();
      this._txBuilder.set_collateral(Wt(t));
    }
  }
  async addRequiredSignersIfNeeded() {
    if (this._initiator && this.notVisited("setRequiredSigners")) {
      const t = await this._initiator.getUsedAddress(), e = Z(t.to_bech32());
      this._txBuilder.add_required_signer(z(e));
    }
  }
  async addTxInputsAsNeeded() {
    if (this._txBuilder.set_inputs(this._txInputsBuilder), this.notVisited("setTxInputs")) {
      const t = !this.notVisited("mintAsset") || !this.notVisited("sendAssets") || !this.notVisited("sendValue"), e = await this.selectLovelaceUTxOs(!1), i = await this.filterAvailableUTxOs(e), r = t ? n.CoinSelectionStrategyCIP2.LargestFirstMultiAsset : n.CoinSelectionStrategyCIP2.LargestFirst;
      this._txBuilder.add_inputs_from(i, r);
    }
    if (this.notVisited("redeemValue") === !1) {
      const t = this._era !== void 0 ? Gt[this._era] : Gt.BABBAGE;
      this._txBuilder.calc_script_data_hash(t);
    }
  }
  async forgeAssetsIfNeeded() {
    const t = (e, i) => {
      const r = e.data.assetName, a = e.data.metadata, o = e.unit.slice(0, L);
      if (i && i[o]) {
        const { [o]: A, ...c } = i, h = {
          [r]: a,
          ...A
        };
        return {
          [o]: {
            ...h
          },
          ...c
        };
      }
      return i !== void 0 ? {
        [o]: {
          [r]: a
        },
        ...i
      } : {
        [o]: { [r]: a }
      };
    };
    await this.addBurnInputsIfNeeded(), Array.from(this._totalMints, (e) => ({
      unit: e[0],
      data: e[1]
    })).reduce((e, i) => e.set(i.data.label, t(i, e.get(i.data.label))), /* @__PURE__ */ new Map()).forEach((e, i) => {
      this._txBuilder.add_json_metadatum(n.BigNum.from_str(i), JSON.stringify(e));
    }), this.addMintOutputs();
  }
  async filterAvailableUTxOs(t = []) {
    const e = n.TransactionUnspentOutputs.new();
    return this._initiator === void 0 || (await this._initiator.getUsedUTxOs()).filter((r) => t.find((a) => a.input.txHash === r.input().transaction_id().to_hex()) === void 0).forEach((r) => {
      e.add(r);
    }), e;
  }
  async selectLovelaceUTxOs(t) {
    if (this._initiator === void 0 || t === !1)
      return [];
    const e = await this._initiator.getUsedUTxOs(), i = ss("5000000", e.map((a) => Et(a)));
    return i.map((a) => G(a)).forEach((a) => {
      this._txBuilder.add_input(a.output().address(), a.input(), a.output().amount());
    }), i;
  }
  addMintOutputs() {
    this._recipients.forEach((t, e) => {
      const r = ft(t).multiasset();
      if (r !== void 0) {
        const o = ut(e).next().with_asset_and_min_required_coin_by_utxo_cost(r, zt(this._protocolParameters.coinsPerUTxOSize)).build();
        this._txBuilder.add_output(o);
      }
    });
  }
  notVisited(t) {
    return this.__visits.includes(t) === !1;
  }
};
q([
  j()
], P.prototype, "mintAsset", null);
q([
  j()
], P.prototype, "redeemValue", null);
q([
  j()
], P.prototype, "sendAssets", null);
q([
  j()
], P.prototype, "sendValue", null);
q([
  j()
], P.prototype, "setCollateral", null);
q([
  j()
], P.prototype, "setRequiredSigners", null);
q([
  j()
], P.prototype, "setTxInputs", null);
P = q([
  ks
], P);
const be = (s, t) => {
  const e = s.vkeys();
  if (e !== void 0) {
    const i = /* @__PURE__ */ new Set();
    for (let a = 0; a < e.len(); a += 1)
      i.add(e.get(a).to_hex());
    for (let a = 0; a < t.len(); a += 1)
      i.add(t.get(a).to_hex());
    const r = n.Vkeywitnesses.new();
    return i.forEach((a) => {
      r.add(n.Vkeywitness.from_hex(a));
    }), r;
  }
  return t;
};
class _ {
  _networkId;
  _encryptedSecret;
  constructor(t, e) {
    this._networkId = t, this._encryptedSecret = e;
  }
  getAccount(t, e) {
    return this.accountContext(t, e, (i, r) => {
      const a = Jt(this._networkId, i.to_public().hash(), r.to_public().hash()).to_address().to_bech32(), o = $t(this._networkId, i.to_public().hash()).to_address().to_bech32(), A = bt(this._networkId, r.to_public().hash()).to_address().to_bech32();
      return {
        baseAddress: a,
        enterpriseAddress: o,
        rewardAddress: A
      };
    });
  }
  signData(t, e, i, r) {
    try {
      return this.accountContext(t, e, (a, o) => {
        const A = { payload: r }, c = {
          address: _.resolveAddress(this._networkId, i, a, o),
          key: i.startsWith("stake") ? o : a
        }, { coseSign1: h, coseKey: u } = as(A, c);
        return { signature: h, key: u };
      });
    } catch (a) {
      throw new Error(`An error occurred during signData: ${a}.`);
    }
  }
  signTx(t, e, i, r, a) {
    try {
      const o = de(Fs(r));
      return this.accountContext(t, e, (A, c) => {
        const h = n.Vkeywitnesses.new();
        return _.resolveSigners(r, i, A.to_public().hash().to_hex()).forEach((I) => {
          if (I === A.to_public().hash().to_hex())
            h.add(n.make_vkey_witness(o, A));
          else if (I === c.to_public().hash().to_hex())
            h.add(n.make_vkey_witness(o, c));
          else if (a === !1)
            throw new Error(`Missing key witness for: ${I}`);
        }), h;
      });
    } catch (o) {
      throw new Error(`An error occurred during signTx: ${o}.`);
    }
  }
  static encryptMnemonic(t, e) {
    const i = ue(t.join(" ")), r = Ce(i), a = W(r.as_bytes());
    return r.free(), _.encrypt(a, e);
  }
  static encryptPrivateKey(t, e) {
    const i = n.Bip32PrivateKey.from_bech32(t), r = W(i.as_bytes());
    return i.free(), _.encrypt(r, e);
  }
  static encryptSigningKeys(t, e, i) {
    const r = _.encrypt(t.slice(4), i), a = _.encrypt(e.slice(4), i);
    return [r, a];
  }
  static generateMnemonic(t = 256) {
    return Ue(t).split(" ");
  }
  accountContext(t, e, i) {
    const { paymentKey: r, stakeKey: a } = _.resolveKeys(t, e, this._encryptedSecret), o = i(r, a);
    return r.free(), a.free(), o;
  }
  static decrypt(t, e) {
    try {
      return n.decrypt_with_password(et(e), t);
    } catch {
      throw new Error("The password is incorrect.");
    }
  }
  static encrypt(t, e) {
    const i = Pe("0123456789abcdef"), r = i(64), a = i(24);
    return n.encrypt_with_password(et(e), r, a, t);
  }
  static resolveAddress(t, e, i, r) {
    const a = [
      Jt(t, i.to_public().hash(), r.to_public().hash()),
      $t(t, i.to_public().hash()),
      bt(t, r.to_public().hash())
    ].find((o) => o.to_address().to_bech32() === e);
    if (a !== void 0)
      return a.to_address();
    throw new Error(`Address: ${e} doesn't belong to this account.`);
  }
  static resolveKeys(t, e, i) {
    if (typeof i == "string") {
      const o = _.decrypt(i, e);
      return bs(o, t);
    }
    const r = _.decrypt(i[0], e), a = _.decrypt(i[1], e);
    return {
      paymentKey: n.PrivateKey.from_hex(r),
      stakeKey: n.PrivateKey.from_hex(a)
    };
  }
  static resolveSigners(t, e, i) {
    const r = (A) => {
      const c = (d, w = [], E = 0) => {
        var It, rt, Nt, Mt, Pt;
        if (d === void 0 || E >= d.len())
          return w;
        const S = d.get(E), x = new Array();
        switch (S.kind()) {
          case n.CertificateKind.StakeDeregistration: {
            const C = (It = S.as_stake_deregistration()) == null ? void 0 : It.stake_credential(), k = (C == null ? void 0 : C.kind()) === n.StakeCredKind.Key ? C.to_keyhash() : void 0;
            k && x.push(k.to_hex());
            break;
          }
          case n.CertificateKind.StakeDelegation: {
            const C = (rt = S.as_stake_delegation()) == null ? void 0 : rt.stake_credential(), k = (C == null ? void 0 : C.kind()) === n.StakeCredKind.Key ? C.to_keyhash() : void 0;
            k && x.push(k.to_hex());
            break;
          }
          case n.CertificateKind.PoolRegistration: {
            const C = (Nt = S.as_pool_registration()) == null ? void 0 : Nt.pool_params().pool_owners();
            x.push(...u(C));
            break;
          }
          case n.CertificateKind.PoolRetirement: {
            const C = (Mt = S.as_pool_retirement()) == null ? void 0 : Mt.pool_keyhash();
            C && x.push(C.to_hex());
            break;
          }
          case n.CertificateKind.MoveInstantaneousRewardsCert: {
            const C = (Pt = S.as_move_instantaneous_rewards_cert()) == null ? void 0 : Pt.move_instantaneous_reward().as_to_stake_creds();
            if (C)
              for (let k = 0; k < C.len(); k += 1) {
                const Tt = C.keys().get(k), Vt = Tt.kind() === n.StakeCredKind.Key ? Tt.to_keyhash() : void 0;
                Vt && x.push(Vt.to_hex());
              }
            break;
          }
        }
        return c(d, [...w, ...x], E + 1);
      }, h = (d, w = [], E = 0) => {
        if (d === void 0 || E >= d.len())
          return w;
        const S = d.get(E).index(), x = d.get(E).transaction_id(), It = e.find((rt) => rt.input.outputIndex === S && rt.input.txHash === x.to_hex()) !== void 0 ? i : "OUR_PRINCESS_IS_IN_ANOTHER_CASTLE";
        return h(d, [...w, It], E + 1);
      }, u = (d, w = [], E = 0) => d === void 0 || E >= d.len() ? w : u(d, [...w, d.get(E).to_hex()], E + 1), I = (d, w = [], E = 0) => {
        if (d === void 0 || E >= d.len())
          return w;
        const S = d.keys().get(E).payment_cred(), x = S.kind() === n.StakeCredKind.Key ? S.to_keyhash() : void 0;
        return I(d, x ? [...w, x.to_hex()] : w, E + 1);
      }, p = A.certs(), D = A.collateral(), J = A.inputs(), F = A.required_signers(), T = A.withdrawals();
      return [
        ...c(p),
        ...h(D),
        ...h(J),
        ...u(F),
        ...I(T)
      ];
    }, a = (A) => {
      const c = (u, I = []) => {
        var p, D, J, F;
        if (u)
          for (let T = 0; T < u.len(); T += 1) {
            const d = u.get(T);
            switch (d.kind()) {
              case n.NativeScriptKind.ScriptPubkey: {
                const w = (p = d.as_script_pubkey()) == null ? void 0 : p.addr_keyhash().to_hex();
                return w ? [...I, w] : I;
              }
              case n.NativeScriptKind.ScriptAll:
                return c((D = d.as_script_all()) == null ? void 0 : D.native_scripts(), I);
              case n.NativeScriptKind.ScriptAny:
                return c((J = d.as_script_any()) == null ? void 0 : J.native_scripts(), I);
              case n.NativeScriptKind.ScriptNOfK:
                return c((F = d.as_script_n_of_k()) == null ? void 0 : F.native_scripts(), I);
            }
          }
        return I;
      }, h = A.native_scripts();
      return [
        ...c(h)
      ];
    }, o = R(t);
    return /* @__PURE__ */ new Set([
      ...r(o.body()),
      ...a(o.witness_set())
    ]);
  }
}
const v = "MARI0TIME";
class ii {
  _fetcher;
  _submitter;
  _wallet;
  constructor(t) {
    switch (this._fetcher = t.fetcher, this._submitter = t.submitter, t.key.type) {
      case "mnemonic":
        this._wallet = new _(t.networkId, _.encryptMnemonic(t.key.words, v));
        break;
      case "root":
        this._wallet = new _(t.networkId, _.encryptPrivateKey(t.key.bech32, v));
        break;
      case "cli":
        this._wallet = new _(t.networkId, _.encryptSigningKeys(t.key.payment, t.key.stake ?? "f0".repeat(34), v));
    }
  }
  getPaymentAddress(t = 0) {
    return this._wallet.getAccount(t, v).enterpriseAddress;
  }
  getStakeAddress(t = 0) {
    return this._wallet.getAccount(t, v).rewardAddress;
  }
  getUsedAddress(t = 0) {
    const e = this._wallet.getAccount(t, v);
    return K(e.enterpriseAddress);
  }
  getUsedCollateral(t = N.maxCollateralInputs) {
    throw new Error("getUsedCollateral not implemented.");
  }
  async getUsedUTxOs(t = 0) {
    const e = this._wallet.getAccount(t, v);
    return (await this._fetcher.fetchAddressUTxOs(e.enterpriseAddress)).map((r) => G(r));
  }
  signData(t, e, i = 0) {
    try {
      return this._wallet.signData(i, v, t, e);
    } catch (r) {
      throw new Error(`[AppWallet] An error occurred during signData: ${r}.`);
    }
  }
  async signTx(t, e = !1, i = 0) {
    try {
      const r = this._wallet.getAccount(i, v), a = await this._fetcher.fetchAddressUTxOs(r.enterpriseAddress), o = this._wallet.signTx(i, v, a, t, e), A = R(t), c = A.witness_set(), h = be(c, o);
      return c.set_vkeys(h), n.Transaction.new(A.body(), c, A.auxiliary_data()).to_hex();
    } catch (r) {
      throw new Error(`[AppWallet] An error occurred during signTx: ${r}.`);
    }
  }
  submitTx(t) {
    return this._submitter.submitTx(t);
  }
  static brew(t = 256) {
    return _.generateMnemonic(t);
  }
}
class Kt {
  _walletInstance;
  constructor(t) {
    this._walletInstance = t;
  }
  static getInstalledWallets() {
    return window.cardano === void 0 ? [] : Lt.filter((t) => window.cardano[t] !== void 0).map((t) => ({
      name: window.cardano[t].name,
      icon: window.cardano[t].icon,
      version: window.cardano[t].apiVersion
    }));
  }
  static async enable(t) {
    try {
      const e = await Kt.resolveInstance(t);
      if (e !== void 0)
        return new Kt(e);
      throw new Error(`Couldn't create an instance of wallet: ${t}`);
    } catch (e) {
      throw new Error(`[BrowserWallet] An error occurred during enable: ${e}.`);
    }
  }
  async getBalance() {
    const t = await this._walletInstance.getBalance();
    return fe(ze(t));
  }
  async getChangeAddress() {
    const t = await this._walletInstance.getChangeAddress();
    return nt(t).to_bech32();
  }
  async getCollateral(t = N.maxCollateralInputs) {
    return (await this.getUsedCollateral(t)).map((i) => Et(i));
  }
  getNetworkId() {
    return this._walletInstance.getNetworkId();
  }
  async getRewardAddresses() {
    return (await this._walletInstance.getRewardAddresses()).map((e) => nt(e).to_bech32());
  }
  async getUnusedAddresses() {
    return (await this._walletInstance.getUnusedAddresses()).map((e) => nt(e).to_bech32());
  }
  async getUsedAddresses() {
    return (await this._walletInstance.getUsedAddresses()).map((e) => nt(e).to_bech32());
  }
  async getUtxos() {
    return (await this.getUsedUTxOs()).map((e) => Et(e));
  }
  signData(t, e) {
    const i = K(t).to_hex();
    return this._walletInstance.signData(i, et(e));
  }
  async signTx(t, e = !1) {
    try {
      const i = R(t), r = i.witness_set(), a = await this._walletInstance.signTx(t, e), o = Je(a).vkeys() ?? n.Vkeywitnesses.new(), A = be(r, o);
      return r.set_vkeys(A), W(n.Transaction.new(i.body(), r, i.auxiliary_data()).to_bytes());
    } catch (i) {
      throw new Error(`[BrowserWallet] An error occurred during signTx: ${i}.`);
    }
  }
  submitTx(t) {
    return this._walletInstance.submitTx(t);
  }
  async getUsedAddress() {
    const t = await this._walletInstance.getUsedAddresses();
    return nt(t[0]);
  }
  async getUsedCollateral(t = N.maxCollateralInputs) {
    return (await this._walletInstance.experimental.getCollateral() ?? []).map((i) => Rt(i)).slice(0, t);
  }
  async getUsedUTxOs() {
    return (await this._walletInstance.getUtxos() ?? []).map((e) => Rt(e));
  }
  async getAssets() {
    return (await this.getBalance()).filter((e) => e.unit !== "lovelace").map((e) => {
      const i = e.unit.slice(0, L), r = e.unit.slice(L), a = Ks(i, r);
      return {
        unit: e.unit,
        policyId: i,
        assetName: Xe(r),
        fingerprint: a,
        quantity: e.quantity
      };
    });
  }
  async getLovelace() {
    const e = (await this.getBalance()).find((i) => i.unit === "lovelace");
    return e !== void 0 ? e.quantity : "0";
  }
  async getPolicyIdAssets(t) {
    return (await this.getAssets()).filter((i) => i.policyId === t);
  }
  async getPolicyIds() {
    const t = await this.getBalance();
    return Array.from(new Set(t.map((e) => e.unit.slice(0, L)))).filter((e) => e !== "lovelace");
  }
  static resolveInstance(t) {
    if (window.cardano === void 0)
      return;
    const e = Lt.map((i) => window.cardano[i]).filter((i) => i !== void 0).find((i) => i.name.toLowerCase() === t.toLowerCase());
    return e == null ? void 0 : e.enable();
  }
}
const Ke = "http://localhost:4000/", Hs = "http://localhost:5000/", Ns = `${Ke}access`, Ms = `${Ke}transaction/signtx`;
class ri {
  static getAxiosInstance() {
    return ct.create({
      baseURL: Hs,
      withCredentials: !0
    });
  }
  static getAppId() {
    return window.location.hostname;
  }
  static async openMinaFrontend(t) {
    const e = this.getAppId();
    t.includes("?") ? t = `${t}&appId=${e}` : t = `${t}?appId=${e}`;
    const i = "left=100,top=100,width=540,height=540", r = window.open(t, "meshWindow", i);
    return r || console.error("the window did not open", r), await (async () => new Promise((a) => {
      window.addEventListener("message", async (o) => {
        o.data.target == "minaWallet" && a(o.data);
      });
    }))();
  }
  static async get(t, e = {}) {
    const i = this.getAppId();
    e = {
      ...e,
      appId: i
    };
    try {
      return (await this.getAxiosInstance().get(t, {
        params: e
      })).data;
    } catch {
      console.error("Not logged in");
      return;
    }
  }
  static async enable() {
    return await this.get("wallet/getuserwalletsmeta") === void 0 ? await this.openMinaFrontend(Ns) : !0;
  }
  static async getChangeAddress(t = void 0, e = void 0) {
    return await this.get("wallet/getchangeaddress", {
      walletId: t,
      accountIndex: e
    });
  }
  static async getUtxos(t = void 0, e = void 0) {
    return await this.get("wallet/getutxo", {
      walletId: t,
      accountIndex: e
    });
  }
  static async signTx(t, e = !1) {
    const i = await this.get("wallet/getuserwalletsmeta");
    if (console.log("userWalletsMeta", i), i) {
      const r = await this.openMinaFrontend(`${Ms}?unsignedTx=${t}&partialSign=${e}`);
      if (r instanceof n.Vkeywitnesses) {
        const a = R(t), o = a.witness_set();
        o.set_vkeys(r);
        const A = n.Transaction.new(a.body(), o, a.auxiliary_data()).to_hex();
        return console.log("signedTx", A), A;
      }
    } else
      return;
  }
}
export {
  ii as AppWallet,
  Xs as BlockfrostProvider,
  Kt as BrowserWallet,
  _ as EmbeddedWallet,
  ei as ForgeScript,
  Zs as InfuraProvider,
  ti as KoiosProvider,
  ri as MinaWallet,
  P as Transaction,
  ss as largestFirst,
  is as largestFirstMultiAsset,
  Os as resolveDataHash,
  Gs as resolveEpochNo,
  Ks as resolveFingerprint,
  Ls as resolveLanguageView,
  Rs as resolveNativeScriptHash,
  Z as resolvePaymentKeyHash,
  qs as resolvePlutusScriptAddress,
  Js as resolvePlutusScriptHash,
  zs as resolvePrivateKey,
  $s as resolveScriptRef,
  Ws as resolveSlotNo,
  js as resolveStakeAddress,
  Us as resolveStakeKeyHash,
  ve as resolveTxFees,
  Fs as resolveTxHash
};
